Эмуляция классов на JavaScript
==============================

Вариация на тему эмуляции классического ООП в JavaScript. 

Создание классов
----------------

Для создание класса достаточно объявить имя класса и присвоить ему объект.

Пример создания пустого класса:

```javascript
// "объявили" пустой класс Empty
var Empty = Class( {} );

// ... и создали объект
var e = new Empty();
```

Пример создания более осмысленного класса. 

```javascript
var X = Class({
	// Конструктор объекта
	constructor: function(x)
	{
		// Сохранить переданное значение в свойствах
		this.p = x;
	}, 
	// Некоторый метод
	alert: function()
	{
		// Отобразить свойство
		alert(this.p);
	}
});

var x1 = new X(1);
var x2 = new X(1000);

x1.alert();
x2.alert();
```

Приватные свойства
------------------

Для работы с приватными свойтвами необходимо объявить класс, передав в качестве аргумента функцию. Фактически, функция, являясь оберткой, возвращающей структуру объекта, создаст новое пространство имен, которое будет доступно только одному экземпляру данного класса. 

```javascript
// Класс, который умеет работать с приватными свойствами
var X = Class(function()
{
	// Приватная переменная. 
	// Видна только изнутри экземпляров класса
	// Уникальна для каждого экземпляра
	var p;

	return {
		// Конструктор объекта
		constructor: function(x)
		{
			// Созранить значение в приватном свойтве
			p = x;
		}, 
		// Некоторый метод
		alert: function()
		{
			// Показать значение
			alert(p);
		}
	};
});

var x1 = new X(1);
var x2 = new X(1000);

x1.alert();
x2.alert();
```

Наследование
------------

Наследование реализовано просто. 

```javascript
// Класс "X" объявлен в предыдущем примере
// Здесь мы унаследуем от него все его свойства и методы
// Родительские методы можно перекрывать, реализуя тем самым полиморфизм
// Есть возможность вызова родительского метода через специальное свойство
var Y = Class(X, function()
{
	// Приватная переменная. 
	// Видна только изнутри экземпляров класса
	// Уникальна для каждого экземпляра
	var p;

	return {
		// Конструктор объекта
		constructor: function(x, y)
		{
			// Вызвать родительский конструктор для инициализации его значения
			this.parent.constructor(x);
			// Созранить значение в приватном свойтве
			p = y;
		}, 
		// Некоторый метод
		alert: function()
		{
			// Вызвать родительский метод
			this.parent.alert();
			// Показать значение
			alert(p);
		}
	};
});

var y = new Y(-100, 100);
y.alert();
```

instanceof
----------

Стандартный оператор instanceof в данной реализации не работает. Для правильной проверки принадлежности объекта классу существует метод Class.instanceOf

```javascript
alert([
	y instanceof X, // == false, потому что родительский конструктор не в цепочке прототипов
	y instanceof Y, // == true, "y" является экземпляром класс "Y"

	Class.instanceOf(y, X), // == true
	Class.instanceOf(y, Y), // == true
]);
```
